Project Journey â€” Problem â†’ Solution (Phase by Phase)

Project: secure-cpp-microservice

Goal:
Build a production-style C++ backend service from scratch using modern tooling.

ğŸŸ¢ PHASE 1 â€” Project Foundation & Dependency Hell ğŸ˜„
âŒ Problem
Starting a C++ project in real life is painful because:
 1.External libraries must be installed manually
 2.Different machines â†’ different setups
 3.Build fails on fresh machines
 4.CMake cannot find dependencies
 5.No reproducible builds
This is the classic C++ dependency problem.

âœ… Solution
We introduced:
 vcpkg manifest mode
 CMake toolchain integration
 External libraries:
 cpp-httplib
 nlohmann/json
 spdlog


We built first working endpoint:
GET /health â†’ {"status":"ok"}
ğŸ’¡ What We Achieved
We solved:
ğŸ‘‰ â€œHow do we make C++ builds reproducible?â€
Now anyone can clone and build the project.
This is the first step toward production readiness.




ğŸŸ¡ PHASE 2 â€” Hardcoded Apps Are Not Deployable
âŒ Problem
Our server had hardcoded values:
      server.listen("0.0.0.0", 8080);

Real environments need different configs:
Dev â†’ 8080
Test â†’ 5000
Prod â†’ 443
Docker â†’ ENV based
Hardcoded apps are not deployable.

âœ… Solution
We introduced:

Config module
Environment variable reading
Runtime configuration
Configurable logging level
Clean project architecture
We separated:
main â†’ server â†’ config


ğŸ’¡ What We Achieved
We solved:
ğŸ‘‰ â€œHow do we make apps configurable at runtime?â€
Now the service behaves like a real deployable backend.




ğŸ§ª PHASE 3 â€” Untestable Code Is Dangerous Code
âŒ Problem
Our HTTP route contained business logic.

That means:
We must run server to test logic
Tests depend on networking
Hard to validate correctness
Impossible to automate reliability
This is un-testable architecture.

âœ… Solution
We introduced:
MetricsService (business layer)
Separation of transport vs logic
GoogleTest integration
CMake testing pipeline

We made logic testable without running server.

ğŸ’¡ What We Achieved
We solved:
ğŸ‘‰ â€œHow do we make C++ services testable and reliable?â€
Now we have automated unit tests.
Huge milestone.





ğŸ” PHASE 4 â€” HTTP Is Insecure
âŒ Problem
Service was running on plain HTTP.
This means:
Traffic readable by anyone
No encryption
Not production safe
Modern services must use HTTPS.

âœ… Solution
We added:
OpenSSL via vcpkg
TLS certificates
HTTPS server using cpp-httplib
Modern CMake compile definitions

We debugged real issue:
target_compile_definitions vs add_definitions

ğŸ’¡ What We Achieved
We solved:
ğŸ‘‰ â€œHow do we secure C++ services with TLS?â€
Now service is secure by default.



ğŸ³ PHASE 5 â€” â€œWorks on my machineâ€ Problem
âŒ Problem
App works locally but:
Wonâ€™t run on other machines
Requires manual setup
Requires compilers + dependencies
Not portable

Classic deployment problem.

âœ… Solution
We built:
Multi-stage Dockerfile
Builder image (compilers + vcpkg)
Runtime image (only binary)
Automatic TLS generation in container

We also debugged:
Docker git clone freeze
CI failing due to missing certs

ğŸ’¡ What We Achieved
We solved:

ğŸ‘‰ â€œHow do we ship C++ apps anywhere?â€
Now app runs with one command:
docker run secure-cpp-service


Huge step.
âš™ï¸ PHASE 6 â€” Manual Builds Donâ€™t Scale
âŒ Problem
Without CI/CD:
No automatic build validation
No automated testing
No automated deployment
Manual Docker push

Not scalable.

âœ… Solution
We built full CI/CD pipeline:

CI Workflow
Every push:
Install dependencies
Build project
Run unit tests
Validate Docker build

CD Workflow
Every push to main:
Login to DockerHub
Build image
Push image automatically

ğŸ’¡ What We Achieved
We solved:
ğŸ‘‰ â€œHow do we automate the full software lifecycle?â€
This is real DevOps integration.

ğŸ† FINAL PROJECT TRANSFORMATION
We started with:
Simple C++ HTTP server
We ended with:
Secure, Tested, Containerized, CI/CD Automated
C++ Microservice

ğŸ’¥ Skills Demonstrated by This Project
This single repo now shows:
Modern CMake
Dependency management (vcpkg)
Modular architecture
Unit testing (gtest)
TLS security (OpenSSL)
Multi-stage Docker
CI pipeline (GitHub Actions)
CD pipeline (DockerHub)

Linux-first development

This is end-to-end engineering.
